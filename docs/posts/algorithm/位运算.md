---
tag: 算法
description: 位运算基础以及常见用法
---

# 位运算

::: details TOC
[[toc]]
:::


## 基础
**运算符号**
> &、|、^、~、<<、>>



| 符号 | 描述 | 运算规则                                                     |
| ---- | ---- | ------------------------------------------------------------ |
| &    | 与   | 两个位都为 1 时，结果才为 1                                  |
| \|   | 或   | 两个位都为 0 时，结果才为 0                                  |
| ^    | 异或 | 两个位相同为 0，相异为 1                                     |
| ~    | 取反 | 0 变 1，1 变 0                                               |
| <<   | 左移 | 各二进位全部左移若干位，高位丢弃，低位补 0（左移运算相当于乘 2^n） |
| >>   | 右移 | 各二进位全部右移若干位，对无符号位，高位补 0；对有符号位，各编译器处理方法不一样，有的补符号位（算术右移），有的补 0（逻辑右移）。（右移运算相当于除 2^n） |



**原/反/补码**

- **原 码**，一个整数按照绝对值大小转化成的二进制数称为原码

  例如，`0000 1110` 是 14 的原码

- **反 码**，将二进制数按位取反，所得到的新二进制数称为原二进制数的反码。原码和反码这两者互为反码

  例如，将 `0000 1110` 每一位取反，得 `1111 0001`

- **补 码**，反码加1称为补码

  `1111 0001 + 0000 0001 = 1111 0010`



**按位与运算**

> 参加运算的两个数据，按二进制位进行`&`运算。两位同时为 1 时，结果才为 1，否则为 0



**运算规则**

```
0&0=0 0&1=0 1&0=0 1&1=1
3&5 ==> 0000 0011 & 0000 0101 = 0000 0001
3&5 = 1
```



**与运算用途**

1. **清零**

   如果想将一个单元清零，即使其全部二进制位为 0，只要与一个各位都为 0 的数值进行与运算，结果为 0

2. 取一个数的**指定位**

   比如，取数 `N=10101110` 的低 4 位，只需要另找一个数 M，令 M 的低 4 位为 1，其余位为 0，即 `M=00001111`，然后 N 与 M 进行与运算，`N&M=00001110` ，即可得到 N 的指定位

3. **判断奇偶**

   只要根据最末位是 0 还是 1 来判断，是 0 就是偶数，是 1 就是基数。因此可以用`if((n & 1) == 1)`或`if((n & 1) == 0)`来判断奇偶



**按位或运算**

> 参加运算的两个数据，按二进制位进行`|`运算。两个位都为 0 时，结果才为 0



**运算规则**

```
0|0=0 0|1=1 1|0=1 1|1=1
3|5 ==> 0000 0011 | 0000 0101 = 0000 0111
3|5 = 7
```

需要注意的是，负数按补码形式参加按位或运算

**运算用途**

1. 常用来对一个数据的某些位设置为 1

   比如，将数 `X=1010 1110` 的低 4 位设置为 1，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即`Y=0000 1111`，然后将 X 与 Y 进行按位或运算（`X|Y=1010 1111`）即可得到



**异或运算**

> 参加运算的两个数据，按二进制位进行`^`运算。两个位相同为 0，相异为 1



**运算规则**

```
0^0=0 0^1=1 1^0=1 1^1=0
```

**异或的性质**

1. 交换律
2. 结合律，`(a^b)^c == a^(b^c)`
3. 对任何数 a，都有 `a^a=0`，`a^0=a`
4. 自反性，`a^b^b=a^0=a`

**运算用途**

1. 翻转指定位

   比如，将数 `X=1010 1110` 的低 4 位进行翻转，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 `Y=0000 1111`，然后将 X 与 Y 进行异或运算（`X^Y=1010 0001`）即可得到

2. 与 0 相异或值不变

   `1010 1110 ^ 0000 0000 = 1010 1110`

3. 交换两个数

```c
// a=0000 0001
// b=0000 1111
void Swap(int &a, int &b){
    if (a != b){
        // a = a^b = 0000 1110
        a ^= b;
        // b = b^a = 0000 0001
        b ^= a;
        // a = a^b = 0000 1111
        a ^= b;
    }
}
```

4. 找出数组中只出现过一次的数

```java
/**
* 找出数组中只出现过一次的数
*/
public static void single(int [] a) {
    int temp = 0;
    for (int i = 0; i < a.length; i++) {
        // 异或运算
        temp ^= a[i];
    }
    System.out.println(temp);
}
```

> 这种解法在数组中只有一个数字出现奇数次，其他数字都出现偶数次的情况下适用。



**取反运算**

> 参加运算的一个数据，按二进制位进行`~`运算。0 变 1，1 变 0



**运算规则**

```
~1=0
~0=1
```

**运算用途**

1. 使一个数的最低位为 0

   例如，有一个数 a，使 a 的最低位为 0，可以表示为`a & ~1`。`~1`的值为 `1111 1110`，再按`&`运算，最低位一定为 0。因为`~`运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高



**左移运算**

> 将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补 0）



**运算规则**

```
// a= 0000 0001 = 1
a = a << 2 = 0000 0100 = 4
相当于，a*2^2 = 1*4 = 4
```



**右移运算**

> 将一个数的各二进制位全部右移若干位，正数左补 0，负数左补 1，右边丢弃



**运算规则**

```
// a= 0000 1000 = 8
a = a >> 2 = 0000 0010 = 2
相当于，a/2^2 = 8/4 = 2
// 无符号右移，左补0，右边丢弃
a = a >>> 2
```



**复合运算**

> 位运算符与赋值运算符结合，组成新的复合赋值运算符



**运算符**

| 运算符 | 例子  | 等价于 |
| ------ | ----- | ------ |
| &=     | a&=b  | a=a&b  |
| \|=    | a\|=b | a=a\|b |
| >>=    | a>>=b | a=a>>b |
| <<=    | a<<=b | a=a<<b |
| ^=     | a^=b  | a=a^b  |



**运算规则**

不同长度的数据进行位运算，如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，正数左补 0，负数左补 1，然后进行位运算



## 应用



### 实现加法

**实现步骤**

1. 不考虑进位，分别将各位数相加，结果存为 sum

2. 只考虑进位，结果存为 carry

3. 如果步骤 2 中的 carry 不为 0，则将 sum 和 carry 相加重复步骤 1 的操作

   如果 carry=0，运算结束，sum 即为运算结果

**举例说明**

十进制例，例如， 13+9

1. 不考虑进位，第一步得 sum=12
2. 不考虑进位，第二步得 carry=10
3. 判断 carry 是否为 0，carry 结果不是 0，将 sum 和 carry 相加重复步骤 1 操作
4. 不考虑进位，新一轮的 sum=22
5. 只考虑进位，新一轮的 carry=0
6. 判断 carry 是否为 0，carry=0，运算结束，结果即为 sum

二进制例，例如，13 的二进制为 `0000 1101`，9 的二进制为 `0000 1001`

1. 不考虑进位，分别对各位数相加，`sum = 0000 1101 + 0000 1001 = 0000 0100`，在位运算中，相当于**异或运算**
2. 只考虑进位，`carry = 0000 1101 + 0000 1001 = 0001 0010`，在为运算中，相当于**先进行与运算，再将结果左移1位**
3. 判断 carry 是否为 0，为 0 结束，否则重复

**代码实现**

```java
/**
 * 位运算实现加法，递归实现
 */
public static int add(int a, int b) {
    if (b == 0) {
        return a;
    } else {
        // 先异或
        int sum = a ^ b;
        // 再进行与，然后左移1位
        int carry = (a & b) << 1;
        return add(sum, carry);
    }
}
```



### 实现减法

> 减法可以看成被减数加上减数的补码



**实现步骤**

1. 取得减数的反码，即 1 变 0，0 变 1
2. 将减数的`反码+1`，得到减数的**补码**
3. 将**被减数与减数的补码相加**

**代码实现**

```java
/**
 * 位运算实现减法
 */
public static int subtraction(int a, int b) {
    b = ~b + 1;
    return add(a, b);
}
```



### 实现乘法

>  十进制乘法的步骤对于二进乘法也适用



**实现步骤**

1. 判断**乘数是否为 0**，为 0 跳到 ④
2. 将**乘数和 1 作与运算**，确定末尾是 1 还是 0，如果是 1，则**相加数为当前被乘数**；如果为 0，则**相加数为 0**；将**所有的相加数加到一起**，就是最终结果
3. 被乘数左移 1 位，乘数右移 1 位，回到步骤 ①
4. 确定符号位，输出结果

**代码实现**

```java
/**
 * 位运算实现乘法
 * @param a 被乘数
 * @param b 乘数
 * @return int
 */
public static int multi(int a, int b) {
    int res = 0;
    // 1. 判断乘数是否为0，为0直接返回0
    while (b != 0) {
        // 确定末尾是1还是0
        if ((b & 1) == 1) {
            // 末尾为1，相加数是当前被乘数
            res += a;

            // 移位
            a = a << 1;
            b = b >> 1;
        } else {
            // 末尾为0，相加数为0
            // res += 0，res不用执行操作

            // 移位
            a = a << 1;
            b = b >> 1;
        }
    }
    return res;
}
```



### 实现除法



**实现思路**

- 除法可以转换成减法运算，即用被除数不断减去除数，直到被除数小于除数，此时两个数相减的次数就是商，而最终的被除数就是余数。
- 需要注意的是符号的确定，商的符号和乘法运算中的乘积的符号确定一样，取决于被除数和除数，同号为正，异号为负；余数的符号和被除数一致



**代码实现**

```java
/**
 * 位运算实现除法
 * @param a 被除数
 * @param b 除数
 * @return int
 */
public static int division(int a, int b) {
    int res = 0;
    if (a < b) {
        return 0;
    } else {
        res = division(subtraction(a, b), b) + 1;
        return res;
    }
}
```



<br>

## 参考

[彻底搞清楚Java的位运算（位实现加减乘除）](https://blog.csdn.net/DBC_121/article/details/103668004)
