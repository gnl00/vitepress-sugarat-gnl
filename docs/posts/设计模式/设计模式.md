---
description: Java 设计模式笔记
tag:
  - 设计模式
  - Java
---

# 设计模式



## 模式分类

**创建型**

1. 单例模式
2. 工厂模式
3. 抽象工厂模式
4. 原型模式
5. 建造者模式

**结构型**

1. 适配器模式
2. 桥接模式
3. 装饰模式
4. 组合模式
5. 外观模式
6. 享元模式
7. 代理模式

**行为型**

1. 模板方法模式
2. 命令模式
3. 访问者模式
4. 迭代器模式
5. 观察者模式
6. 中介者模式
7. 备忘录模式
8. 解释器模式
9. 状态模式
10. 策略模式
11. 职责链模式



## 单例模式

> 单例模式（Singleton），采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象的实例，并且该类只提供一个取得其对象实例的方法



- 饿汉
- 线程安全懒汉
- 静态内部类
- 枚举

```java
/**
 * 单例模式
 */

public class SingletonTest {
    public static void main(String[] args) {
        Singleton1 obj1 = Singleton1.getInstance();
        Singleton1 obj2 = Singleton1.getInstance();

        // true
        System.out.println(obj1 == obj2);

        Singleton4 instance1 = Singleton4.INSTANCE;
        Singleton4 instance2 = Singleton4.INSTANCE;
        System.out.println(instance1 == instance2);
    }
}

/**
 * 饿汉式
 * 优 线程安全
 * 缺 对象加载在内存中的时间长
 */
class Singleton1 {

    // 私有化构造方法，确保只能通过向外暴露的public方法获取对象
    private Singleton1() {}

    // 加载类的时候就将对象创建好
    private static Singleton1 instance = new Singleton1();

    public static Singleton1 getInstance() {
        return instance;
    }

}

/**
 * 懒汉式
 * 优 延迟对象创建时间
 * 缺 线程不安全 需要使用同步代码来进行双重检查保证线程安全
 */
class Singleton2 {

    private Singleton2() {}

    // volatile 禁止对象在创建时指令重排
    private static volatile Singleton2 instance = null;

    public static Singleton2 getInstance() {
        if (instance == null) {
            synchronized (Singleton2.class) {
                if (instance == null) {
                    instance = new Singleton2();
                }
            }
        }

        return instance;
    }

}

/**
 * 静态内部类
 */
class Singleton3 {
    private Singleton3(){}

    /**
     * 提供一个静态内部类，该类中声明一个返回对象类型的静态属性
     */
    private static class Singleton3Instance {
        private static final Singleton3 INSTANCE = new Singleton3();
    }

    public static Singleton3 getInstance() {
        return Singleton3Instance.INSTANCE;
    }
}

/**
 * 枚举实现单例
 */
enum Singleton4 {
    INSTANCE;
    public void getInstance() {
        System.out.println("get enum instance...");
    }
}
```



## 工厂模式

### 简单工厂

```java
// 简单工厂
public class SimpleFactory {
    public static Pizza getInstance(String name) {

        Pizza pizza = null;

        while (null != name || !"".equals(name)) {
            if ("greek".equals(name)) {
                pizza = new GreekPizza();
                break;
            } else if ("cheese".equals(name)) {
                pizza = new CheesePizza();
                break;
            } else {
                break;
            }
        }
		
        // 返回需要的对象实例
        return pizza;
    }
}
```



### 工厂方法

> 工厂方法模式（Factory Method）定义了一个用于创建对象的接口/抽象类，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟加载到其子类



```java
public abstract class PizzaOrder {
    abstract Pizza getInstance(String name);
}

public class BJPizzaOrder extends PizzaOrder {

    @Override
    Pizza getInstance(String name) {
		Pizza pizza = null;
        if (name.equals("cheese")) {
            pizza = new BJCheesePizza();
        } else if ("greek".equals(name)) {
            pizza = new BJGreekPizza();
        }
        // 返回需要的对象实例
        return pizza;
    }
}
```



### 抽象工厂

> 抽象工厂模式（Abstract Factory）抽象工厂 = 简单工厂 + 工厂方法



```java
public abstract class AbsFactory {
    public abstract Pizza getInstance(String name);
}

public class BJAbsFactory extends AbsFactory {

    @Override
    public Pizza getInstance(String name) {
        Pizza pizza = null;
        if ("greek".equals(name)) {
            pizza = new BJGreekPizza();
        } else  if("cheese".equals(name)) {
            pizza = new BJCheesePizza();
        }
        return pizza;
    }
}
```



## 原型模式

> 原型模式（Prototype），用原型实例指定创建对象的种类，并通过拷贝这些原型，创建新的对象



**优点**

- 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能提高效率
- 不用重新初始化对象，而是动态地获得对象运行时的状态
- 如果原始对象发生变化，其他克隆对象也会发生相应的变化，无需修改代码

**缺点**

- 需要为每一个类配备一个`clone()`方法，这对全新的类来说不是很难，但是对于已有类进行改造时，需要修改源代码，违背了OCP原则
- 在实现深拷贝的时候可能需要比较复杂的代码

### 浅拷贝

- 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性的值复制一份给新的对象
- 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是将该成员变量的引用值（内存地址）复制一份给新对象。因为实际上两个对象的引用类型成员变量都指向同一个实例，所以在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。

```java
/**
 * PrototypeTest 浅拷贝
 */

public class PrototypeTest {
    public static void main(String[] args) {
        PrototypeUser user1 = new PrototypeUser("zss", "123456", new PrototypeDepartment("1", "java"));
        PrototypeUser user2 = (PrototypeUser) user1.clone();

        System.out.println(user1);
        System.out.println(user2);
        // false
        System.out.println(user1 == user2);
        // true
        System.out.println(user1.getDepartment() == user2.getDepartment());

    }
}

class PrototypeUser implements Cloneable {

    private String username;
    private String password;
    private PrototypeDepartment department;

    public PrototypeUser() {
    }

    public PrototypeUser(String username, String password, PrototypeDepartment department) {
        this.username = username;
        this.password = password;
        this.department = department;
    }

    public PrototypeDepartment getDepartment() {
        return department;
    }

    public void setDepartment(PrototypeDepartment department) {
        this.department = department;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    @Override
    protected Object clone() {

        PrototypeUser clone = null;

        try {
            clone = (PrototypeUser) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }

        return clone;
    }

    @Override
    public String toString() {
        return "PrototypeUser{" +
                "username='" + username + '\'' +
                ", password='" + password + '\'' +
                ", department=" + department +
                '}';
    }
}

class PrototypeDepartment {
    private String id;
    private String name;

    public PrototypeDepartment() {
    }

    public PrototypeDepartment(String id, String name) {
        this.id = id;
        this.name = name;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "PrototypeDepartment{" +
                "id='" + id + '\'' +
                ", name='" + name + '\'' +
                '}';
    }
}
```

### 深拷贝

- 复制对象的所有基本数据类型的成员变量值
- 为所有引用数据类型的成员变量申请内存空间，并复制每个引用数据类型成员变量所引用的对象，即对象进行深拷贝要对整个对象进行拷贝

**实现**

1. 重写`clone()`方法
2. 通过对象序列化实现

```java
/**
 * PrototypeTest 深拷贝
 */
public class PrototypeTest {
    public static void main(String[] args) {
        PrototypeUser user1 = new PrototypeUser("zss", "123456", new PrototypeDepartment("1", "java"));
        PrototypeUser user2 = (PrototypeUser) user1.deepCloneV2();

        System.out.println(user1);
        System.out.println(user2);
        // false
        System.out.println(user1 == user2);
        // false
        System.out.println(user1.getDepartment() == user2.getDepartment());

    }
}

class PrototypeUser implements Cloneable, Serializable {

    private static final long serialVersionUID = 1L;

    private String username;
    private String password;
    private PrototypeDepartment department;

    public PrototypeUser() {
    }

    public PrototypeUser(String username, String password, PrototypeDepartment department) {
        this.username = username;
        this.password = password;
        this.department = department;
    }

    public PrototypeDepartment getDepartment() {
        return department;
    }

    public void setDepartment(PrototypeDepartment department) {
        this.department = department;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    /**
     * 浅拷贝
     */
    @Override
    protected Object clone() {

        PrototypeUser clone = null;

        try {
            // 完成基本数据类型的克隆
            clone = (PrototypeUser) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }

        return clone;
    }

    /**
     * 深拷贝
     */
    protected Object deepClone() {
        PrototypeUser clone = null;
        try {
            // 完成基本数据类型的克隆
            clone = (PrototypeUser) super.clone();
            // 对引用类型的属性进行单独处理
            clone.department = (PrototypeDepartment) department.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }

        return clone;
    }

    /**
     * 序列化方式实现深拷贝
     */
    protected Object deepCloneV2() {
        PrototypeUser clone = null;

        // 创建流对象
        ByteArrayOutputStream baos = null;
        ByteArrayInputStream bais = null;
        ObjectOutputStream oos = null;
        ObjectInputStream ois = null;

        try {
            // 1. 先序列化
            baos = new ByteArrayOutputStream();
            oos = new ObjectOutputStream(baos);

            // 2. 将当前对象以流的形式输出
            oos.writeObject(this);

            // 3. 反序列化
            bais = new ByteArrayInputStream(baos.toByteArray());
            ois = new ObjectInputStream(bais);
            clone = (PrototypeUser) ois.readObject();
            return clone;
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
            return null;
        } finally {
            try {
                baos.close();
                bais.close();
                oos.close();
                ois.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }

    @Override
    public String toString() {
        return "PrototypeUser{" +
                "username='" + username + '\'' +
                ", password='" + password + '\'' +
                ", department=" + department +
                '}';
    }
}

class PrototypeDepartment implements Cloneable, Serializable {

    private static final long serialVersionUID = 2L;

    private String id;
    private String name;

    public PrototypeDepartment() {
    }

    public PrototypeDepartment(String id, String name) {
        this.id = id;
        this.name = name;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "PrototypeDepartment{" +
                "id='" + id + '\'' +
                ", name='" + name + '\'' +
                '}';
    }
}
```



## 建造者模式

> 建造者模式（Builder），又称为生成器模式，它可以将复杂对象的建造过程抽象出来，使这个抽象过程的不同实现方法可以构造出不同属性的对象



建造者模式是一步步创建一个复杂对象，它允许用户通过指定复杂对象的类型和内容就可以构建对象，用户不需要知道内部的具体构建细节

**角色**

1. Product（产品角色），一个具体的产品对象
2. Builder（抽象建造者），创建一个Product对象各个部件指定的接口
3. ConcreteBuilder（具体建造者），实现接口，构建和装配各个部件
4. Director（指挥者），构建一个使用Builder接口的对象，它主要是用于创建一个复杂对象。主要有两个作用：一是隔离用户与对象的生产过程，二是负责控制产品对象的生产过程

**细节**

1. 客户端不必知道产品内部的组成细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象
2. 每一个具体建造者都相互独立，因此可以很方便的替换具体建造者或是增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象
3. 可以更加精细地控制产品地创建过程，将复杂产品地创建步骤分解在不同地方法中，使得创建过程更加清晰，也更方便实用程序来控制创建过程
4. 增加新的具体建造者虚无修改原有的类库代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合开闭原则



```java
/**
 * Builder
 * @author gnl
 */
public abstract class Builder {

    protected House house = new House();

    /**
     * buildFunction
     */
    abstract void buildFunction();

    /**
     * buildWall
     */
    abstract void buildWall();

    /**
     * buildRoof
     */
    abstract void buildRoof();

    public House buildHouse() {
        return house;
    }
}

/**
 * ConcreteBuilder
 * @author gnl
 */
public class ConcreteBuilder extends Builder {

    @Override
    void buildFunction() {}

    @Override
    void buildWall() {}

    @Override
    void buildRoof() {}
}

/**
 * Director
 * @author gnl
 */
public class Director {
    private Builder builder;

    public Director(Builder builder) {
        this.builder = builder;
    }

    /**
     * 将建造流程交给Director
     */
    public House construct() {
        this.builder.buildFunction();
        this.builder.buildWall();
        this.builder.buildRoof();
        System.out.println("All done.");
        return this.builder.buildHouse();
    }
}

/**
 * Client
 * @author gnl
 */
public class Client {
    public static void main(String[] args) {
        Director director = new Director(new CommonHouse());
        director.construct();
    }
}
```



## 适配器模式

> 适配器（Adapter），别名包装器（Wrapper），将某个类的接口换成客户端期望的另一个接口表示，主要目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作



**分类**

1. 类适配器模式，使用类继承的方式实现
2. 对象适配器模式，使用组合方式代替继承来实现，使用成本更低、灵活，更经常使用

**原理**

1. 将一个类的接口转换成另一种接口，让原本不兼容的类可以兼容
2. 从用户的角度来看是接触不到适配者的，是解耦的
3. 用户调用【适配器转化出来的目标接口方法】，适配器再调用【被适配者的相关接口方法】



```java
/**
 * ClassAdapterTest 类适配器
 *
 * @author gnl
 */

public class ClassAdapterTest {
    public static void main(String[] args) {
        Phone phone = new Phone();
        phone.charge(new VoltageAdapter());
    }
}

interface Voltage5V{
    int output5V();
}

class Voltage220V {
    public int output220V() {
        return 220;
    }
}

class VoltageAdapter extends Voltage220V implements Voltage5V {
    @Override
    public int output5V() {
        int source = output220V();
        return source/44;
    }
}

class Phone {
    public void charge(Voltage5V voltage5V) {
        if (voltage5V.output5V() == 5) {
            System.out.println("Voltage is 5V, charging now...");
        } else {
            System.out.println("Voltage is not 5V, can not charge");
        }
    }
}

/**
 * ObjectAdapterTest 对象适配器
 *
 * @author gnl
 */

public class ObjectAdapterTest {
    public static void main(String[] args) {
        Voltage5V adapter = new VoltageAdapter(new Voltage220V());
        new Phone().charge(adapter);
    }
}

interface Voltage5V{
    int output5V();
}

class Voltage220V {

    public int output220V() {
        return 220;
    }
}

class VoltageAdapter implements Voltage5V {

    // 使用聚合的方式将Voltage220V对象聚合到VoltageAdapter中
    private Voltage220V voltage220V;

    public VoltageAdapter(Voltage220V voltage220V) {
        this.voltage220V = voltage220V;
    }

    @Override
    public int output5V() {
        int source = voltage220V.output220V();
        return source/44;
    }
}

class Phone {
    public void charge(Voltage5V voltage5V) {
        if (voltage5V.output5V() == 5) {
            System.out.println("Voltage is 5V, charging now...");
        } else {
            System.out.println("Voltage is not 5V, can not charge");
        }
    }
}
```



## 桥接模式

> 桥接模式（Bridge），将实抽象与实现部分分离，使两个部分可以独立改变



桥接模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。特点就是把抽象与行为实现分离开，从而保持各个部分的独立性以及功能扩展



**细节**

1. 实现了抽象与实现部分的分离，从而极大地提升了系统的灵活性，让抽象部分和实现部分独立开，有助于系统进行分层设计，从而产生更好的结构化系统。
2. 对于系统高层部分，只需要知道抽象部分和实现部分的接口即可，其他部分由具体业务来完成
3. 桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本
4. 桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程
5. 桥接模式要求正确识别出系统中两个独立变化的维度（抽象和具体实现），因此其使用范围具有一定的局限性，即需要有这样的应用场景

**优点**

1. 分离抽象接口及其实现部分
2. 桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则， 复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法
3. 桥接模式提高了系统的可扩充性，在两个变化维度（抽象与实现）中任意扩展一个维度，都不需要修改原有系统

**缺点**

1. 桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程
2. 桥接模式要求正确识别出系统中两个独立变化的维度（抽象和具体实现），因此其使用范围具有一定的局限性



```java
/**
 * Brand
 *
 * @author gnl
 */

public interface Brand {
    void sale();
}

class Lenovo implements Brand {

    @Override
    public void sale() {
        System.out.println("lenovo");
    }
}

class Dell implements Brand {

    @Override
    public void sale() {
        System.out.println("dell");
    }
}

class HP implements Brand {

    @Override
    public void sale() {
        System.out.println("hp");
    }
}

/**
 * Computer
 *
 * @author gnl
 */

public class Computer {
    protected Brand brand;

    public Computer(Brand brand) {
        this.brand = brand;
    }

    public void sale() {
        brand.sale();
    }
}

class Desktop extends Computer {
    public Desktop(Brand brand) {
        super(brand);
    }

    @Override
    public void sale() {
        super.sale();
        System.out.println("Sale desktop");
    }
}

class Laptop extends Computer {

    public Laptop(Brand brand) {
        super(brand);
    }

    @Override
    public void sale() {
        super.sale();
        System.out.println("Sale laptop");
    }
}

class Pad extends Computer {
    public Pad(Brand brand) {
        super(brand);
    }

    @Override
    public void sale() {
        super.sale();
        System.out.println("Sale pad");
    }
}

/**
 * Client
 *
 * @author gnl
 */

public class Client {
    public static void main(String[] args) {
        Computer laptop = new Laptop(new Lenovo());
        laptop.sale();
    }
}
```



## 装饰者模式

> 装饰者模式（Decorator），动态地将新功能附加到对象上，在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则（OCP）



**角色**

- Component，抽象被装饰类，增加功能时的核心角色，Component角色只是定义了接口/抽象方法
- ConcreteComponent，具体被装饰类，实现Component所定义的接口/抽象方法
- Decorator，抽象装饰类，继承自Component，具有与Component相同的方法，从外部扩展Component类的功能
- ConcreteDecorator，具体装饰类，起到给Component增加功能的作用



**细节**

- 与继承关系相比，关联关系主要优势在于不会破坏类的封装性，而且继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展。在软件开发阶段，关联关系虽然不会比继承关系减少编码量，但是到了软件维护阶段，由于关联关系使系统具有较好的松耦合性，因此使得系统更加容易维护。关联的缺点是比继承关系要创建更多的对象
- 使用装饰者模式来实现扩展比继承更加灵活，更有弹性。能【动态的将新功能附加到对象上】

**缺点**

- 使用装饰者模式将产生很多小的对象，而这些对象的区别在于它们之间相互连接的方式有所不同；同时还将产生很多具体装饰类。这些装饰类和小对象的存在将增加系统的复杂度，加大学习与理解的难度
- 装饰者模式比继承更加灵活机动的特性也意味着装饰者模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐

**使用时机**

- 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责

- 需要动态地给一个对象增加功能，这些功能也可以被动态地撤销

- 当不能采用继承地方式对系统进行扩充，或者采用继承不利于系统扩展和维护时

  不能采用继承的情况有

  1. 类是继承中存在大量独立的扩展，为支持一种组合将产生大量的子类，使得子类数目呈爆炸式增长
  2. 类使用final修饰



```java
/**
 * Drink Component
 *
 * @author gnl
 */

public abstract class Drink {

    private String desc;
    private float price;

    /**
     * cost 计费
     * @return float
     * @author gnl
     */
    public abstract float cost();

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    public float getPrice() {
        return price;
    }

    public void setPrice(float price) {
        this.price = price;
    }

}

/**
 * Juice ConcreteComponent
 *
 * @author gnl
 */

public class Juice extends Drink {
    @Override
    public float cost() {
        return super.getPrice();
    }
}

/**
 * OrangeJuice ConcreteComponent
 *
 * @author gnl
 */

public class OrangeJuice extends Juice {
    public OrangeJuice() {
        setDesc("OrangeJuice");
        setPrice(1.5f);
    }
}

/**
 * Decorator 装饰类
 *
 * @author gnl
 */

public abstract class Decorator extends Drink {

    /**
     * 将Drink类聚合到Decorator中
     */
    private Drink drink;

    public Decorator(Drink drink) {
        this.drink = drink;
    }

    @Override
    public float cost() {
        return super.getPrice() + drink.cost();
    }


    @Override
    public String getDesc() {
        return super.getDesc() + super.getPrice() +" + "+ drink.getDesc() + drink.getPrice();
    }
}

/**
 * Milk ConcreteDecorator
 *
 * @author gnl
 */

public class Milk extends Decorator {

    public Milk(Drink drink) {
        super(drink);
        setDesc("milk");
        setPrice(2.0f);
    }
}

/**
 * Client
 * @author gnl
 */

public class Client {
    public static void main(String[] args) {
        Decorator milk = new Milk(new OrangeJuice());
        System.out.println(milk.getDesc());
        System.out.println(milk.cost());
    }
}
```



## 组合模式

> 组合模式（Composite Pattern），又称部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示**整体——部分**的层次关系

**角色**

- Component，容器对象，组合中对象声明接口/抽象类，在适当情况下实现所有共有类接口的默认行为。用于访问和管理 *Component* 子部件，
- Leaf，叶子对象，在组合中表示叶子节点，叶子节点没有子节点，不能操作子节点，但它定义组合内元素的行为
- Composite，非叶子节点，用户存储 *Leaf* 和 *Composite* 子部件，并实现子部件的相关操作。*Composite* 可以操作子节点和叶子节点，但不一定具有叶子节点的某种行为/功能

**优点**

- 可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，使得增加新构建也更容易
- 定义了包含叶子对象和容器对象的类层次结构，叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，方便形成复杂的树形结构
- 具有较强的扩展性，更容易在组合体内加入对象构件，只需要调整内部的层次关系，客户端不必因为加入了新的对象构件而做出改动
- 客户端调用简单，客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题，并且可以同时使用组合结构或其中单个对象

**缺点**

- 使得设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大的挑战性，而且不是所有的方法都与叶子对象子类有关联
- 增加新构件可能会产生一些问题，很难对容器中的构件类型进行限制

**使用时机**

- 当要处理的对象可以生成一棵树型结构，而且要对数上的节点和叶子进行操作时，它能够提供一致的方式，而不用考虑它是叶子还是节点
- 需要遍历组织机构，或者处理的对象具有树形结构时，非常适合使用组合模式
- 要求较高的抽象性，如果节点和叶子有很多差异性的化，比如很多方法和属性都不一样，不适合使用组合模式



```java
/**
 * Component
 *
 * @author gnl
 */

public abstract class Component {

    private String name;
    private String desc;

    public Component(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    /**
     * add
     * @param component
     * @return void
     * @author gnl
     */
    public void add(Component component) {
        throw new UnsupportedOperationException();
    }

    /**
     * remove
     * @param component
     * @return void
     * @author gnl
     */
    public void remove(Component component) {
        throw new UnsupportedOperationException();
    }

    /**
     * show
     * @return void
     * @author gnl
     */
    protected abstract void show();
}

/**
 * University Composite
 * 可以管理College
 *
 * @author gnl
 */

public class University extends Component {

    /**
     * components 存放College
     */
    private List<Component> components = new ArrayList<>();

    public University(String name, String desc) {
        super(name, desc);
    }

    @Override
    public String getName() {
        return super.getName();
    }

    @Override
    public String getDesc() {
        return super.getDesc();
    }

    @Override
    public void add(Component component) {
        components.add(component);
    }

    @Override
    public void remove(Component component) {
        components.remove(component);
    }

    /**
     * 输出 University 包含的 College
     * @return void
     */
    @Override
    protected void show() {
        System.out.println("==="+getName()+"===");
        components.stream().map(Component::getName).forEach(System.out::println);
    }
}

/**
 * College Composite
 *
 * @author gnl
 */

public class College extends Component {

    /**
     * components 存放Department
     */
    private List<Component> components = new ArrayList<>();

    public College(String name, String desc) {
        super(name, desc);
    }

    @Override
    public String getName() {
        return super.getName();
    }

    @Override
    public String getDesc() {
        return super.getDesc();
    }

    @Override
    public void add(Component component) {
        components.add(component);
    }

    @Override
    public void remove(Component component) {
        components.remove(component);
    }

    /**
     * 输出 College 包含的 Department
     * @return void
     */
    @Override
    protected void show() {
        System.out.println("==="+getName()+"===");
        components.stream().map(Component::getName).forEach(System.out::println);
    }
}

/**
 * Department Leaf
 *
 * @author gnl
 */

public class Department extends Component {

    // 叶子节点，不需要集合

    public Department(String name, String desc) {
        super(name, desc);
    }

    // 叶子节点，不需要重写add和remove方法

    @Override
    protected void show() {
        System.out.println(getName());
    }
}

/**
 * Client
 *
 * @author gnl
 */

public class Client {
    public static void main(String[] args) {
        Component university = new University("jxnu", "jxnu good good good");
        Component sos = new College("sos", "sos nb");

        university.add(sos);
        university.add(new College("teach", "teach good"));
        university.add(new College("cs", "cs good good"));

        sos.add(new Department("web", "web1111"));
        sos.add(new Department("android", "android22222"));
        sos.add(new Department("big data", "bigdata3333"));

        university.show();
        sos.show();
    }
}
```



## 外观模式

> 外观模式（Facade），又称过程模式，外观模式为子系统中的一组接口提供一个一致使用的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加易用。外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节



**角色**

- Facade，外观类，为调用端提供统一的调用接口，外观类知道哪些子系统负责处理请求，从而将调用端的请求代码给适当子系统对象
- SubClasses，子系统类集合，指子模块或子系统，处理Facade对象指派的任务，它是功能的实际提供者
- Client，外观接口的调用者

**细节**

- 外观模式就是解决多个复杂接口带来的使用困难，起到了简化用户操作的作用
- 外观模式对外屏蔽子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性
- 外观模式对客户端与子系统的耦合关系，让子系统内部的模块更加易于维护和扩展
- 通过合理的使用外观模式，可以帮我们更好的划分访问的层次
- 当系统需要进行分层设计时，可以考虑使用外观模式
- 在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个外观类，用来提供遗留系统的比较清晰简单的接口，让新系统与外观类交互，提高复用性
- 不能过多的或者不合理的使用外观模式，使用外观模式好还是直接调用好，要以让系统有层次，利于维护为目的
- 不要试图通过继承外观类在子系统中增加新行为，这一做法是错误的。外观模式的用意是为子系统提供一个集中化和简化的沟通渠道，而不是向子系统中加入新的行为，新行为的增加应该通过修改原有子系统类或增加新的子系统类来实现，不能通过外观类来实现



```java
/**
 * Player SubClass
 * @author gnl
 */
public class Player {

    private Player() {}

    private final static Player INSTANCE = new Player();

    public static Player getInstance() {
        return INSTANCE;
    }

    public void on() {
        System.out.println("player on");
    }
    public void off() {
        System.out.println("player off");
    }
    public void play() {
        System.out.println("player play");
    }
    public void pause() {
        System.out.println("player pause");
    }

}

/**
 * Facade
 * @author gnl
 */
public class Facade {

    private Player player = Player.getInstance();
    private Screen screen = Screen.getInstance();
    private Light light = Light.getInstance();

    public void start() {
        screen.down();
        player.on();
        light.on();
    }
    public void play() {
        player.play();
        light.focus();
    }
    public void pause() {
        player.pause();
        light.fade();
    }
    public void end() {
        player.off();
        screen.up();
        light.off();
    }

}

/**
 * Client
 * @author gnl
 */
public class Client {
    public static void main(String[] args) {
        Facade facade = new Facade();

        facade.start();
        System.out.println("===============");

        facade.play();
        System.out.println("===============");

        facade.pause();
        System.out.println("===============");

        facade.end();
    }
}
```



## 享元模式

> 享元模式（Flyweight Pattern），又称蝇量模式，运用共享技术有效地支持大量细粒度的对象，能解决重复对象的内存浪费问题



**角色**

- Flyweight，抽象享元角色，它是产品的抽象类，同时定义出对象的外部形态（频繁变化的，每个对象不一样的）和内部状态（比较稳定的）的接口或实现
- ConcreteFlyweight，具体的享元角色，是具体的产品类，实现抽象角色的相关业务，并未内部状态增加存储空间
- FlyweightFactory，享元工厂类，用来创建并管理享元对象。它主要用来确保合理地是共享Flyweight，用户请求一个Flyweight时，享元工厂对象提供一个已创建的实例或是创建一个（如果实例不存在的话）。用于构件一个容器池（集合），同时提供从池中获取对象的方法。工厂类中都是内部状态，一般不会出现外部状态
- UnSharedConcreteFlyweight，指不需要共享的享元角色，Flyweight接口使共享成为可能，但它不强制共享。一般不会出现在享元工厂

**细节**

- 享元模式提出了两个要求：细粒度和共享对象。这里就涉及到内部状态和外部状态，即对象信息分为两个部分：内部状态和外部状态。【内部状态】指的是对象共享出来的信息，存储在享元对象内部且不会随环境的变化而变化。【外部状态】指对象得以依赖的一个标记，是随环境改变而改变的 ，不可共享的状态。使用享元模式时注意划分内部和外部状态，并且需要一个工厂类加以控制。
- 享元模式能够解决重复对象的内存浪费问题，当系统中有大量相似对象需要缓冲池（常用HashMap/Hashtable存储）时，不需总是创建对象，可以使用享元对象唯一标识码，从缓冲池中拿。这样就可以降低系统内存，同时提高效率
- 享元模式经典的应用场景就是【池技术】，String常量池、数据库连接池、缓冲池等



## 代理模式

> 代理模式（Proxy），为一个对象提供一个替身，用来控制这个对象的访问，即通过代理对象访问目标对象。这样做的好处是可以在目标对象实现的基础上，额外增加功能操作，即扩展目标对象的功能



### 静态代理

> 静态代理（Static Proxy）在使用时，需要定义接口或者父类，被代理对象（即目标对象）与代理对象一起实现相同的接口或是继承相同的父类，再由代理对象调用目标对象的对应方法



**优点**

- 在不修改目标对象的功能前提下，能够通过代理对象对目标功能扩展

**缺点**

- 代理对象需要与目标对象实现一样的接口，所以会有很多实现类。一旦接口增加方法，目标对象和代理对象的代码都要修改



```java
/**
 * 静态代理
 * 代理类和被代理类在编译期间就已经确定
 * @author gnl
 */

public class StaticProxyTest {
    public static void main(String[] args) {
        // 创建被代理对象
        Factory clothFactory = new ClothFactory();

        // 创建代理对象
        ProxyFactory proxyFactory = new ProxyFactory(clothFactory);

        // 代理对象执行方法
        proxyFactory.doProduce();
    }
}

// 被代理接口类
interface Factory {

    /**
     * doProduce
     */
    void doProduce();
}

// 被代理实现类
class ClothFactory implements Factory {
    @Override
    public void doProduce() {
        System.out.println("服装厂进行工作。。。");
    }
}

/**
 * 代理类
 */
class ProxyFactory implements Factory {

    private Factory factory;

    public ProxyFactory(Factory factory) {
        this.factory = factory;
    }

    @Override
    public void doProduce() {
        System.out.println("代理工厂做准备工作哦");

        factory.doProduce();

        System.out.println("代理工厂做后续工作哦");
    }
}

```



### 动态代理

**分类**

1. JDK动态代理（接口代理）
   - 代理对象不需要实现接口，但是目标对象需要实现接口，否则不能用JDK动态代理
   - 代理对象的生成，是利用JDK的API，动态地在内存中创建代理对象
2. CGLib动态代理（类代理）
   - 静态代理和JDK动态代理都要求目标对象实现一个接口，但是有时候对象只是一个单独的对象，并没有实现任何接口，这个时候就可使用目标对象子类来实现代理，CGLib代理的目标对象不需要实现接口
   - CGLib代理也叫做子类代理，它是在内存中创建一个子类对象从而实现对目标对象功能扩展
   - CGLib是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现Java接口。它广泛的被许多AOP框架使用，如SpringAOP，实现方法拦截
   - 在AOP中如何选择代理模式：目标对象需要实现接口，使用JDK代理；目标对象不需要实现接口，使用CGLib代理
   - CGLib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类



```java
/**
 * DynamicProxyTest 反射实现动态代理
 *
 * @author gnl
 */

public class DynamicProxyTest {
    public static void main(String[] args) {

        // 可以实现不编写实现类，直接执行某个 interface 的方法

        // 将返回的 Object 强制转型为接口
        Animal proxyInstance = (Animal) DProxyFactory.getProxyInstance(new Man());

        System.out.println(proxyInstance.skill());
        proxyInstance.eat("rice");
    }
}

interface Animal {

    /**
     * skill
     * @return java.lang.String
     */
    String skill();

    /**
     * eat
     * @param food
     * @return void
     */
    void eat(String food);

}

/**
 * 被代理类
 */
class Man implements Animal {

    @Override
    public String skill() {
        return "i can work";
    }

    @Override
    public void eat(String food) {
        System.out.println("eat: " + food);
    }
}

/**
 * 被代理类
 */
class Dog implements Animal {

    @Override
    public String skill() {
        return "i can run";
    }

    @Override
    public void eat(String food) {
        System.out.println("eat: " + food);
    }
}

/**
 * 代理类
 */
class MyInvocationHandler implements InvocationHandler {

    /**
     * 注入被代理类
     */
    private Object obj;

    public MyInvocationHandler(Object obj) {
        this.obj = obj;
    }

    /**
     * invoke 执行方法
     *
     * @param proxy 代理类
     * @param method 执行的方法
     * @param args 方法参数
     * @return 返回方法执行后得到的返回值
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        System.out.println(proxy.getClass());

        System.out.println("方法执行前 ===》do something");

        // 执行方法 获得返回值
        Object returnVal = method.invoke(obj, args);

        System.out.println("方法执行后 ===》do something");

        return returnVal;
    }
}

/**
 * 代理类工厂 调用工厂返回代理类
 *
 */
class DProxyFactory {
    public static Object getProxyInstance(Object obj) {
        MyInvocationHandler handler = new MyInvocationHandler(obj);

        // 通过JDK提供的一个Proxy.newProxyInstance() 方法创建某个接口对象
        return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler);
    }
}
```



## 模板方法

> 模板方法模式（Template Method），当实现的功能有一部分确定，另一部分不确定时，可以把不确定的部分暴露出去，让子类实现



**细节**

- 模板方法模式结构中只有类之间的继承关系，没有对象的关联关系
- 在模板方法中，可以将相同的代码放到父类中，而将不同的方法实现放在不同的子类中
- 一般模板方法都加上final关键字，防止子类重写模板方法
- 模板方法的不足之处在于，每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大



```java
/**
 * 模板方法模式
 * @author gnl
 */

public class TemplateTest {
    public static void main(String[] args) {
        SubTemlpate subTemlpate = new SubTemlpate();
        subTemlpate.runTime();
    }
}

abstract class Template {

    /**
     * 模板中的不确定部分
     */
    abstract void code();

    public void runTime() {
        long start = System.currentTimeMillis();

        code();

        long end = System.currentTimeMillis();

        System.out.println(String.format("花费时间为: %d", end-start));

    }
}

class SubTemlpate extends Template {

    @Override
    void code() {

        for (int i = 2; i < 1000; i++) {
            boolean isFlag = true;
            for (int j = 2; j < Math.sqrt(i); j++) {
                if ( i % j ==0){
                    isFlag = false;
                    break;
                }
            }
            if (isFlag){
                System.out.println(i);
            }

        }
    }
}
```



## 命令模式

> 命令模式（Command Pattern），将请求封装成一个对象，使用不同参数来表示不同的请求（即命名）。能将命令的发送与命令的执行分开，同时命令模式也支持可撤销的操作



**角色**

- Command，抽象命令角色/命令接口，声明需要执行的所有命令
- Receiver，接收者，接收需要执行的命令，知道如何实施和执行一个请求相关的操作，任何类都可能是接收者
- ConcreteCommand，具体命令类，将一个接收和一个动作绑定，调用接收的相应操作，实现命令的执行
- Invoker，命令的调用者，发起执行命令请求

**细节**

- 将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的`execute()`方法，就可让接收者工作，不必知道具体的接收者对象是谁以及如何实现。命令对象会负责让接收者执行请求的动作，即调用者和接收者的解耦是通过命令对象来实现的，命令对象起到桥梁纽带的作用
- 命令模式使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦
- 可以将命令设计成队列，只要那命令对象放到队列中，就可以多线程的执行命令
- 命令模式容易实现对命令的撤销和重做
- 空命令也是命令模式的一部分，使用空命令可省去判空操作，若没有使用空命令，每次执行命令之前都需要对命令进行判空
- 命令模式的不足之处在于，它可能会导致某些系统有过多的具体命令类，增加了系统的复杂度



```java
/**
 * Command 接口
 * @author gnl
 */

public interface Command {
    /**
     * execute
     * @return void
     */
    void execute();

    /**
     * undo
     * @return void
     */
    void undo();
}

/**
 * EmptyCommand 空命令
 * @author gnl
 */
public class EmptyCommand implements Command {

    @Override
    public void execute() {}

    @Override
    public void undo() {}
}

/**
 * DoCommand ConcreteCommand
 * @author gnl
 */
public class DoCommand implements Command {

    private Receiver receiver;
    private String functionName;

    public DoCommand(Receiver receiver, String functionName) {
        this.receiver = receiver;
        this.functionName = functionName;
    }

    @Override
    public void execute() {
        receiver.execute(this.functionName);
    }

    @Override
    public void undo() {
        receiver.undo(this.functionName);
    }
}

/**
 * Receiver 接收者
 * @author gnl
 */
public class Receiver {

    public void execute(String function) {
        System.out.println("执行功能: " + function);
    }

    public void undo(String function) {
        System.out.println("撤销功能: " + function);
    }

}

/**
 * Invoker
 * @author gnl
 */
public class Invoker {

    private Command command;

    private Command undoCommand;

    public Invoker() {
        this.command = new EmptyCommand();
    }

    public void setCommand(Command command) {
        this.command = command;
    }

    public void setUndoCommand(Command undoCommand) {
        this.undoCommand = undoCommand;
    }

    public void executeCommand() {
        this.command.execute();
    }

    public void undoCommand() {
        this.undoCommand.undo();
    }
}

/**
 * Client
 * @author gnl
 */
public class Client {
    public static void main(String[] args) {
        Invoker helpInvoker = new Invoker();
        Invoker functionInvoker = new Invoker();

        Receiver receiver = new Receiver();

        Command helpCommand = new DoCommand(receiver, "打开帮助手册");
        Command functionCommand = new DoCommand(receiver, "执行某功能");

        helpInvoker.setCommand(helpCommand);
        helpInvoker.setUndoCommand(helpCommand);

        functionInvoker.setCommand(functionCommand);

        helpInvoker.executeCommand();
        helpInvoker.undoCommand();

        functionInvoker.executeCommand();
    }
}
```



## 访问者模式

> 访问者模式（Visitor Pattern），表示一个作用于某对象结构中的各元素操作。它可以在不改变各个元素的类的前提下定义作用于这些元素的新操作，在被访问的类里面加一个对外提供接待访问者的接口，主要是将数据结构于数据操作分离，解决数据结构和操作耦合的问题



**角色**

- Visitor，抽象访问者，为ObjectStructure中ConcreteElement的每一个类声明一个用于访问的`visit()`操作
- ConcreteVisitor，具体访问者，实现由Visitor声明的所有`visit()`操作，即实现如何处理每个ConcreteElement角色
- Element，Element角色表示Visitor的访问对象，内部声明了接受访问者的`accept()`方法，`accept()`方法接收到的参数是Visitor角色
- ConcreteElement，负责实现由Element所定义的方法
- ObjectStructure，对象结构，负责处理Element角色集合

**细节**

- 当一个对象就结构中的对象需要经常处理许多不同的操作，但是这些操作之间没有关联，同时需要避免这些操作污染这些对象的类，可以使用访问者模式

- **优点**
  1. 访问者模式符合单一职责原则，让程序具有优秀的扩展性，灵活性高
  2. 访问者模式可以对功能进行统一，适用于数据结构相对稳定的系统

- **缺点**
  1. 具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，造成具体元素修改比较困难
  2. 违背了依赖倒转原则，访问者依赖的是具体元素，而不是抽象元素



```java
/**
 * Person Element
 * @author gnl
 */

public abstract class Person {

    private String name;
    private Integer essayCount;
    private Integer score;

    public Person(String name, Integer essayCount, Integer score) {
        this.name = name;
        this.essayCount = essayCount;
        this.score = score;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getEssayCount() {
        return essayCount;
    }

    public void setEssayCount(Integer essayCount) {
        this.essayCount = essayCount;
    }

    public Integer getScore() {
        return score;
    }

    public void setScore(Integer score) {
        this.score = score;
    }

    /**
     * award 获得的奖项
     * @return void
     * @author gnl
     */
    public abstract void award();

    /**
     * accept 接受visitor访问，参数为Visitor
     * @param visitor
     * @return void
     * @author gnl
     */
    public abstract void accept(Visitor visitor);

}

/**
 * Teacher ConcreteElement
 *
 * @author gnl
 */

public class Teacher extends Person {

    public Teacher(String name, Integer essayCount, Integer score) {
        super(name, essayCount, score);
    }

    @Override
    public void award() {
        if (this.getEssayCount() > 10){
            System.out.println("***** 教师: "+getName()+" 【可】评选科研奖");
        } else {
            System.out.println("***** 教师: "+getName()+" 【不可】评选科研奖");
        }

        if (this.getScore() > 90){
            System.out.println("***** 教师: "+getName()+" 【可】评选成绩优秀奖");
        } else {
            System.out.println("***** 教师: "+getName()+" 【不可】评选成绩优秀奖");
        }
    }

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}

/**
 * Student ConcreteElement
 *
 * @author gnl
 */

public class Student extends Person {

    public Student(String name, Integer essayCount, Integer score) {
        super(name, essayCount, score);
    }

    @Override
    public void award() {
        if (this.getEssayCount() > 2){
            System.out.println("***** 学生: "+getName()+" 【可】评选科研奖");
        } else {
            System.out.println("***** 学生: "+getName()+" 【不可】评选科研奖");
        }

        if (this.getScore() > 90){
            System.out.println("***** 学生: "+getName()+" 【可】评选成绩优秀奖");
        } else {
            System.out.println("***** 学生: "+getName()+" 【不可】评选成绩优秀奖");
        }
    }

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}

/**
 * Visitor
 * @author gnl
 */

public abstract class Visitor {

    /**
     * visit 用于访问Element
     * @param element
     * @return void
     * @author gnl
     */
    public abstract void visit(Person element);

}

/**
 * ConcreteVisitor
 * @author gnl
 */

public class ConcreteVisitor extends Visitor {

    /**
     * visit 访问person
     * @param element
     * @return void
     * @author gnl
     */
    @Override
    public void visit(Person element) {
        element.award();
    }
}

/**
 * ObjectStructure 负责处理Element角色
 * @author gnl
 */

public class ObjectStructure {

    private List<Person> elements = new ArrayList<>();

    public boolean addElement(Person person) {
        if (person != null) {
           return elements.add(person);
        }
        return false;
    }

    public boolean removeElement(Person person) {
        if (elements.contains(person)) {
            return elements.remove(person);
        }
        return false;
    }

    public void showElement(Visitor visitor) {
        elements.forEach(p -> {
            p.accept(visitor);
        });
    }

}

/**
 * Client
 * @author gnl
 */

public class Client {
    public static void main(String[] args) {

        Person tea1 = new Teacher("t-aaa", 11, 99);
        Person tea2 = new Teacher("t-bbb", 5, 89);

        Person stu1 = new Student("s-ccc", 11, 99);
        Person stu2 = new Student("s-ddd", 1, 89);

        ObjectStructure objectStructure = new ObjectStructure();

        objectStructure.addElement(tea1);
        objectStructure.addElement(tea2);
        objectStructure.addElement(stu1);
        objectStructure.addElement(stu2);

        objectStructure.showElement(new ConcreteVisitor());

    }
}
```



## 迭代器模式

> 迭代器模式（Iterator），提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示



**角色**

- Iterator，迭代器接口，由系统提供，其内含有`hashNext()`、`next()`、`remove()`等方法
- ConcreteIterator，具体的迭代类，管理元素的迭代
- Aggregate，统一聚合接口，将客户端和迭代具体实现解耦
- ConcreteAggregate，聚合接口实现类，具体的聚合实现类持有对象集合，并提供一个返回迭代器的方法，使用返回的迭代器可正确遍历集合

**细节**

- 如果集合元素是用不同的方式实现的，有数组，也有集合类，或者还有其他方式，当客户端要遍历这些元素的时候就要使用多种遍历方式，并且还会暴露元素内部的结构。此时就可以考虑使用迭代器模式来解决

- 迭代器模式中应用了工厂方法模式，聚合类充当工厂类

- 优点

  1、提供了一个统一的方法遍历对象，客户端不用再考虑聚合的类型，使用一种方法就可以遍历对象了

  2、隐藏了聚合的内部结构，客户端要遍历集合的时候只能获取到迭代器，而不会知道聚合的具体组成

  3、提供了一种设计思想，即一个欸应该只有一个引起变化的原因（单一责任制）。在聚合类中，把迭代器分开，就是要把管理对象集合和遍历对象集合的责任分开。在后续的操作中，若是改变集合只会影响到聚合对象；若遍历方式改变，之影响到迭代器

  4、当要展示一组相似的对象，或者遍历一组相同对象时，适合使用你迭代器模式

- 缺点

  每个聚合对下个都要一个迭代器，会生成多个迭代器，不好管理类



```java
/**
 * Department
 * @author gnl
 */

public class Department {

    private String name;
    private String desc;

    public Department(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

/**
 * Aggregate
 * @author gnl
 */

public interface Aggregate {

    /**
     * getName
     * @return java.lang.String
     */
    public String getName();

    /**
     * addElement
     * @param department
     * @return void
     */
    public void addElement(Department department);

    /**
     * createIterator
     * @return java.util.Iterator
     */
    public Iterator createIterator();

}

/**
 * ConcreteAggregate
 */

public class ConcreteAggregate implements Aggregate {

    private List<Department> departments;

    public ConcreteAggregate() {
        this.departments = new ArrayList<>();
    }

    @Override
    public String getName() {
        return "ConcreteAggregate";
    }

    @Override
    public void addElement(Department department) {
        if (department != null) {
            departments.add(department);
        }
    }

    @Override
    public ConcreteIterator createIterator() {
        return new ConcreteIterator(this.departments);
    }
}

/**
 * ConcreteIterator
 * @author gnl
 */

public class ConcreteIterator implements Iterator {

    private List<Department> departments;
    private int index = -1;

    public ConcreteIterator(List<Department> departments) {
        this.departments = departments;
    }

    @Override
    public boolean hasNext() {
        if (index >= (departments.size()-1)){
            return false;
        }else{
            index += 1;
            return true;
        }
    }

    @Override
    public Object next() {
        return departments.get(index);
    }

    @Override
    public void remove() {}

    public void show() {
        while (hasNext()) {
            Department department = (Department) next();
            System.out.println(department.getName());
        }
    }
}

/**
 * Client
 * @author gnl
 */

public class Client {
    public static void main(String[] args) {

        Department sos = new Department("sos", "sos good");
        Department cs = new Department("cs", "cs good");
        Department tea = new Department("tea", "tea good");
        Department phy = new Department("phy", "phy good");

        ConcreteAggregate aggregate = new ConcreteAggregate();
        aggregate.addElement(sos);
        aggregate.addElement(cs);
        aggregate.addElement(tea);
        aggregate.addElement(phy);

        ConcreteIterator iterator = aggregate.createIterator();
        System.out.println(iterator.hasNext());

        iterator.show();

    }
}
```



## 观察者模式

> 观察者模式（Observer Pattern），又称发布订阅模式，定义对象间一种一对多依赖关系，让多个观察者对象同时监听某个主题对象，这个主题对象状态发生变化时，会通知所有的观察者对象，让它们自己能够自动更新。



**角色**

- Observer，抽象观察者对象，负责接收来自Subject角色的状态变化通知，内部声明`update()`方法，用于得到变化通知时更新
- ConcreteObserver，具体观察者对象，当`update()`方法被调用后，会去获取观察对象的最新状态
- Subject，抽象观察对象，Subject角色定义了注册观察者和删除观察者的方法，此外还声明了获取现在状态的方法
- ConcreteSubject，具体观察对象，表示具体的被观察对象，当自身状态发生变化后，会通知所有已经注册的观察者

**细节**

- 观察者模式的关键对象是观察目标和观察者，目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者。一个目标可以有任意数目的观察者，一旦目标状态发生变化，所有观察者都将得到通知
- 作为对通知的响应，每个观察者将即时更新自己的状态，以与目标状态同步，这种交互也称为发布-订阅（Publish-Subscribe）
- 观察者模式的使用
  1. 一个抽象模型有两个方面，其中一个方面依赖另一个方面。将这些面封装在独立的对象中使它们可以独立地改变和复用
  2. 一个对象地改变将导致其他一个或多个对象也发生改变，而不知道具体多少个对现象发生了改变，可以降低对象之间的耦合度
  3. 一个对象必须通知其他对象，而不知道这些对象是谁
- 优点
  1. 观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的信息更新传递机制，抽象了更新接口，可以用不同的表示层作为具体观察者角色
  2. 观察者模式在观察目标和观察者之间建立了一个抽象的耦合
  3. 观察者模式支持广播通信
  4. 观察者模式符合开闭原则
- 缺点
  1. 如果一个观察者目标对象有很多直接和简介观察者的话，将所有的观察者都通知到会花费很多时间
  2. 如果在观察者或者观察目标之间有循环依赖的话，观察目标会触发它们之间的循环调用，可能导致系统崩溃
  3. 观察者模式没有相应的机制让观察者知道所观察对象是怎么发生变化的，而仅仅只是知道观察对象发生了变化



```java
/**
 * Observer
 * @author gnl
 */
public interface Observer {

    /**
     * update
     * @param temperature
     * @return void
     * @author gnl
     */
    public void update(float temperature);
}

/**
 * ConcreteObserver
 * @author gnl
 */

public class ConcreteObserver implements Observer {

    private float temperature;

    @Override
    public void update(float temperature) {
        this.temperature = temperature;
        show();
    }

    public void show() {
        System.out.println("ConcreteObserver temperature: " + this.temperature);
    }
}

/**
 * Subject
 * @author gnl
 */

public interface Subject {

    /**
     * registerObs
     * @param observer
     * @return void
     * @author gnl
     */
    public void registerObs(Observer observer);

    /**
     * removeObs
     * @param observer
     * @return void
     * @author gnl
     */
    public void removeObs(Observer observer);

    /**
     * notifyObs
     * @return void
     * @author gnl
     */
    public void notifyObs();

}

/**
 * ConcreteSubject
 * @author gnl
 */

public class ConcreteSubject implements Subject {

    private float temperature;
    private List<Observer> observers;

    public ConcreteSubject() {
        this.observers = new ArrayList<>();
    }

    public float getTemperature() {
        return temperature;
    }

    public void setTemperature(float temperature) {
        this.temperature = temperature;
        dataChanged();
    }

    @Override
    public void registerObs(Observer observer) {
        this.observers.add(observer);
    }

    @Override
    public void removeObs(Observer observer) {
        this.observers.remove(observer);
    }

    @Override
    public void notifyObs() {
        this.observers.forEach(obs -> {
            obs.update(this.temperature);
        });
    }

    public void dataChanged() {
        notifyObs();
    }
}

/**
 * Client
 * @author gnl
 */

public class Client {
    public static void main(String[] args) {

        ConcreteObserver observer = new ConcreteObserver();
        TemperatureObserver tObserver = new TemperatureObserver();

        ConcreteSubject subject = new ConcreteSubject();

        subject.registerObs(observer);
        subject.registerObs(tObserver);

        subject.setTemperature(25.3f);

    }
}
```



## 中介者模式

> 中介者模式（Mediator Pattern），用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式的相互引用，从而使耦合松散，而且可以独立的改变它们之间的交互



**角色**

- Mediator，抽象中介者，定义了Colleague对象到中介者对象的接口
- ConcreteMediator，具体的中介对象，实现抽象方法，它需要知道所有的具体同事类，即以一个集合来管理同事类，并接收同事对象消息，完成相应的任务
- Colleague，抽象同事类
- ConcreteColleague，具体同事类，存在多个，每个同事只知道自己的行为，而不了解其他同事的行为（方法），但它们都依赖中介者对象

**细节**

- 中介者模式可以使对象之间的关系数量急剧减少

- 中介者模式减少类之间的依赖，降低了耦合，符合迪米特法则

- 中介者承担两方面职责

  1. 中转作用（结构性）
  2. 协调作用（行为性）

- 多个类相互耦合，会形成网状结构，可使用中介者模式将网状结构分离为星型结构，进行解耦

- 优点

  1. 简化了对象之间的交互
  2. 将各个同事类解耦
  3. 减少子类生成
  4. 可以简化各个同事类的设计和实现

- 缺点

  中介者承担了较多的职责，一旦中介者出现了问题，整个系统就会受到影响。如果设计不当，中介者对象本身会变得过于复杂




```java
/**
 * Mediator
 *
 * @author gnl
 */

public interface Mediator {

    /**
     * register 将同事对象加入集合
     * @param colleague
     * @param name
     * @return void
     * @author gnl
     */
    public void register(Colleague colleague, String name);

    /**
     * getMessage 接收同事对象传过来的消息，完成相应任务
     * @param colleagueName
     * @return void
     * @author gnl
     * @date 2021/4/8 10:45
     */
    public void getMessage(String colleagueName);

}

/**
 * ConcreteMediator
 *
 * @author gnl
 */

public class ConcreteMediator implements Mediator {

    private Map<String, Colleague> colleagueMap;
    private Map<String, String> memberMap;

    public ConcreteMediator() {
        this.colleagueMap = new HashMap();
        this.memberMap = new HashMap();
    }

    @Override
    public void register(Colleague colleague, String name) {
        colleagueMap.put(name, colleague);

        if (colleague instanceof CommonMember) {
            memberMap.put("common", name);
        } else if (colleague instanceof  VipMember) {
            memberMap.put("vip", name);
        }

    }

    @Override
    public void getMessage(String colleagueName) {
        if (colleagueMap.get(colleagueName) instanceof CommonMember) {
            String member = memberMap.get("common");
            colleagueMap.get(member).sendText();
        }
        if (colleagueMap.get(colleagueName) instanceof VipMember) {
            String member = memberMap.get("vip");
            colleagueMap.get(member).sendText();
            colleagueMap.get(member).sendPicture();

        }
    }
}

/**
 * Colleague
 *
 * @author gnl
 */

public interface Colleague {

    /**
     * sendText
     * @return void
     * @author gnl
     */
    public void sendText();

    /**
     * sendPicture
     * @return void
     * @author gnl
     */
    public void sendPicture();

}

/**
 * CommonMember ConcreteColleague
 *
 * @author gnl
 * @date 2021-04-08 10:50
 */

public class CommonMember implements Colleague {

    @Override
    public void sendText() {
        System.out.println("CommonMember sendText");
    }

    @Override
    public void sendPicture() {
        throw new UnsupportedOperationException();
    }
}

/**
 * VipMember ConcreteColleague
 *
 * @author gnl
 */

public class VipMember implements Colleague {

    @Override
    public void sendText() {
        System.out.println("VipMember sendText");
    }

    @Override
    public void sendPicture() {
        System.out.println("VipMember sendPicture");
    }
}


/**
 * Client
 *
 * @author gnl
 */

public class Client {
    public static void main(String[] args) {

        ConcreteMediator mediator = new ConcreteMediator();

        CommonMember commonMember = new CommonMember();
        VipMember vipMember = new VipMember();

        mediator.register(commonMember, "common");
        mediator.register(vipMember, "vip");

        mediator.getMessage("common");
        mediator.getMessage("vip");

    }
}
```



## 备忘录模式

> 备忘录模式（Memento Pattern），在不破坏封装性的前提下，捕获对象的下一个内部状态，并在该对象之外保存这个状态，这样以后就可以将该对象恢复到原先保存的的状态



**角色**

- Originator，状态生成对象，负责创建备忘录，用于记录当前时刻Originator的内部状态，并可以使用备忘录恢复内部状态，Originator可根据需要决定Momento存储Originator的哪些内部状态
- Memento，备忘录对象，负责保存Originator的内部状态，并可以防止Originator以外的其他对象访问备忘录
- CareTaker，守护对象，负责保存多个备忘录对象，使用集合管理，提高效率。如果希望保存多个Originator对象不同时间的状态，只需要用`HashMap<String，集合>`来做集合管理即可

**细节**

- 备忘录模式给用户提供了一个可以恢复状态的机制，可以使用户能够比较方便回到某个历史状态
- 实现了信息封装，使得用户不需要关心状态保存的信息
- 如果类的成员变量过多，势必会占用较大的资源，而且每一次保存都会消耗一定的内存
- 为了节约内存，备忘录模式可以和原型模式配合使用



```java
/**
 * Originator 保存状态的对象
 *
 * @author gnl
 */

public class Originator {

    private String state;

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    /**
     * saveMementoState 将对象状态保存
     * @return com.demo.memento.Memento
     * @author gnl
     */
    public Memento saveMementoState() {
        return new Memento(this.state);
    }

    /**
     * getMementoState 通过备忘录，恢复对象状态
     * @param memento
     * @return void
     * @author gnl
     */
    public void getMementoState(Memento memento) {
        this.state = memento.getState();
    }

}

/**
 * Memento
 *
 * @author gnl
 */

public class Memento {

    private String state;

    public Memento(String state) {
        this.state = state;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }
}

/**
 * CareTaker
 *
 * @author gnl
 */

public class CareTaker {

    private List<Memento> mementos;

    public CareTaker() {
        this.mementos = new ArrayList<>();
    }

    public void addMemento(Memento memento) {
        mementos.add(memento);
    }

    /**
     * getMemento 获取到第n条备忘录信息
     * @param index
     * @return com.demo.memento.Memento
     * @author gnl
     */
    public Memento getMemento(int index) {
        return mementos.get(index);
    }

}

/**
 * Client
 * @author gnl
 */

public class Client {
    public static void main(String[] args) {

        Originator originator = new Originator();
        CareTaker careTaker = new CareTaker();

        originator.setState("state--0 power--100");
        careTaker.addMemento(originator.saveMementoState());
        originator.setState("state--1 power--90");
        careTaker.addMemento(originator.saveMementoState());
        originator.setState("state--2 power--50");
        careTaker.addMemento(originator.saveMementoState());

        String state_now = "";

        System.out.println("========当前状态========");
        state_now = originator.getState();
        System.out.println(state_now);

        System.out.println("========恢复状态0========");
        originator.getMementoState(careTaker.getMemento(0));
        String state_0 = originator.getState();
        System.out.println(state_0);

        System.out.println("========当前状态========");
        state_now = originator.getState();
        System.out.println(state_now);


    }
}
```



## 解释器模式

> 解释器模式（Interpreter Pattern），指的是给定一个语言（表达式），定义它的文法的一种表示，并定义一个解释器，使用该解释器来解释语言中的句子（表达式）。应用可以将一个需要解释执行的语言中的句子表示为一个抽象语法树，一些重复出现的问题就可以用一种简单的语言来表达



**角色**

- Context，环境角色，含有解释器之外的全局信息
- AbstractExpression，抽象表达式，声明一个抽象的解释操作，这个方法为抽象语法树中所有的结点所共享
- TerminalExpression，终结符表达式，实现与表达式中的终结符相关的解释操作
- NonTerminalExpression，非终结符表达式，为表达式中的非终结符实现解释操作
- Client，Context和TerminalExpression的信息通过Client输入即可

**细节**

- 在编译原理中，一个算数表达式通过词法分析器形成词法单元，而后这些词法单元再通过词法分析器构建语法分析树，最终形成一颗抽象的语法分析树。这里的词法分析器和语法分析器都可以看作是解释器
- 当有一个语言需要解释其执行，可将该语言中的句子表示为一个抽象语法树就可以考虑使用解释器模式，使程序具有良好的扩展性
- 应用场景有，解释器，运算表达式计算，正则表达式，机器人等
- 可能会引起的问题有，类膨胀，解释器模式采用递归调用的方法，将会导致调试非常复杂，效率降低



## 状态模式

> 状态模式（State Pattern），它主要用来解决对象在多种状态转换时，需要对外输出不同的行为的问题。状态和行为是相互对应的，状态之间可以相互转换



**角色**

- Context，环境角色，用于维护 *State* 实例，这个实例定义当前状态
- State，抽象状态角色，定义了一个抽象封装与 *Contex* t的一个状态相关行为
- ConcreteState，具体状态角色，表示各个具体状态

**细节**

- 当一个对象的内在状态改变时，允许改变其行为，使这个对象看起来像是改变了其类
- 代码具有很强的可读性，状态模式将每个状态的行为封装到对应的一个类中
- 方便维护，将容易产生问题的`if-else`语句删除，如果把每个状态的行为都放到一个类中，每次调用方法时都要判断当前是什么状态，不但会产生很多`if-else`语句，而且容易出错
- 符合开闭原则，容易增删状态
- 当一个时间或者对象有很多种状态，状态之间会相互转换，对不同的状态要求有不同的行为的时候，可以考虑使用状态模式
- 优点
  - 封装了转换规则
  - 枚举可能的状态，在枚举之前需要确定状态种类
  - 将所有与某个状态有关的行为都烦到一个类中，并且可以方便的增加新的状态，只需要改变对象状态即可改变对象的行为
  - 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块
  - 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数
- 缺点
  - 会产生很多类，每个状态都要一个对应的类，当状态过多时，会产生很多类，加大了维护难度
  - 状态模式的结构与实现都较为复杂，如果使用不当将导致程序状态和代码的混乱



```java
/**
 * State
 * @author gnl
 */

public interface State {

    /**
     * deposit 存款
     * @param money
     * @return void
     * @author gnl
     */
    public void deposit(Double money);

    /**
     * withdraw 取款
     * @param money
     * @return void
     * @author gnl
     */
    public void withdraw(Double money);

}

/**
 * ConcreteState
 *
 * @author gnl
 */

public class GreenState implements State {

    private Account account;

    public GreenState(Account account) {
        this.account = account;
    }

    @Override
    public void deposit(Double money) {
        account.setBalance(account.getBalance() + money);
        System.out.println("存款: " + money + "\t余额: " + account.getBalance());
    }

    @Override
    public void withdraw(Double money) {
        account.setBalance(account.getBalance() - money);
        System.out.println("取款: " + money + "\t余额: " + account.getBalance());
    }
}

/**
 * ConcreteState
 *
 * @author gnl
 */

public class YellowState implements State {

    private Account account;

    public YellowState(Account account) {
        this.account = account;
    }

    @Override
    public void deposit(Double money) {
        account.setBalance(account.getBalance() + money);
        System.out.println("存款: " + money + "\t余额: " + account.getBalance());
    }

    @Override
    public void withdraw(Double money) {
        account.setBalance(account.getBalance() - money);
        System.out.println("取款: " + money + "\t余额: " + account.getBalance());
    }
}

/**
 * ConcreteState
 *
 * @author gnl
 */

public class RedState implements State {

    private Account account;

    public RedState(Account account) {
        this.account = account;
    }

    @Override
    public void deposit(Double money) {
        account.setBalance(account.getBalance()+money);
        System.out.println("存款: "+money+"\t余额: "+account.getBalance());
    }

    @Override
    public void withdraw(Double money) {
        System.out.println("取款: "+money+"\t余额: "+account.getBalance()+"\t取款失败！当前账户已透支！");
    }
}

/**
 * Action
 *
 * @author gnl
 */

public class Account {

    private State state;
    private Double balance;

    private State gState = new GreenState(this);
    private State yState = new YellowState(this);
    private State rState = new RedState(this);

    public void deposit(Double money) {
        this.state.deposit(money);
    }

    public void withdraw(Double money) {
        this.state.withdraw(money);
    }

    public Account() {
        this.state = gState;
        this.balance = 0.0;
    }

    public State getState() {
        return state;
    }

    public void setState(State state) {
        this.state = state;
    }

    public Double getBalance() {
        return balance;
    }

    public void setBalance(Double balance) {
        this.balance = balance;
        if (this.balance >= 0){
            this.state = gState;
        }
        if (this.balance >= -1000.0 && this.balance < 0){
            this.state = yState;
        }
        if (this.balance < -1000.0){
            this.state = rState;
        }

    }
}

/**
 * Client
 *
 * @author gnl
 */

public class Client {
    public static void main(String[] args) {
        Account account = new Account();

        // green状态
        System.out.println("=== 当前状态 ===");
        System.out.println(account.getState());
        account.deposit(100.0);
        account.withdraw(50.0);
        System.out.println("=======================================");
        account.withdraw(60.0);
        System.out.println("=== 当前状态 ===");
        System.out.println(account.getState());
        System.out.println("=======================================");
        account.withdraw(2000.0);
        System.out.println("=== 当前状态 ===");
        System.out.println(account.getState());
        System.out.println("=======================================");
        account.withdraw(10.0);
        System.out.println("=== 当前状态 ===");
        System.out.println(account.getState());
        System.out.println("=======================================");
        account.deposit(4000.0);
        System.out.println("=== 当前状态 ===");
        System.out.println(account.getState());
    }
}
```



## 策略模式

> 策略模式（Strategy Pattern），定义算法族，分别包装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的用户



**角色**

- Strategy，策略角色，负责决定实现策略所必需的接口（API）
- ConcreteStrategy，具体的策略角色，负责实现Strategy角色的接口，即负责实现具体的策略（方法）
- Context，负责使用Strategy角色，Context角色保存了ConcreteStrategy角色的实例，并使用ConcreteStrategy角色区实现需求

**细节**

- 完成一项任务往往可以通过很多种不同的方式，没一种方式称为一个策略，我们就可以根据环境或者条件的不同而选择不同的策略来完成该任务
- 为了解决这些问题，我们可以定义一些独立的类来封装不同的算法，每个类封装一个具体的算法，而每一个封装算法的类都可以称之为策略。为了保证策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应一个具体的策略
- 策略模式的关键是
  1. 分析项目中变化的部分与不变的部分，把变化的代码从不变的代码中分离出来
  2. 针对接口编程而不是具体类，定义策略接口
  3. 多用关联，少用继承
- 体现了对修改关闭，对扩展开发的开闭原则，客户端如增加行为，不用修改原有的代码，只要添加一种策略（行为）即可。避免了使用多重`if-else-if-else`语句
- 需要注意的是，没添加一个策略，就要新增一个类，当策略过多时会导致类数目庞大





```java
/**
 * Strategy
 * @author gnl
 */

public interface Strategy {

    /**
     * go 出行方式
     * @return void
     * @author gnl
     */
    void go();

}

/**
 * Plane ConcreteStrategy
 *
 * @author gnl
 */

public class Plane implements Strategy {
    @Override
    public void go() {
        System.out.println("Strategy ==> Plane");
    }
}

/**
 * Bike ConcreteStrategy
 *
 * @author gnl
 */

public class Bike implements Strategy {
    @Override
    public void go() {
        System.out.println("Strategy ==> Bike");
    }
}

/**
 * Context
 * @author gnl
 */

public class Context {

    private Strategy strategy;

    public Context() {
        System.out.println("go for trip ~~");
    }

    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }

    public void go() {
        this.strategy.go();
    }
}

/**
 * Client
 *
 * @author gnl
 */

public class Client {
    public static void main(String[] args) {
        Context context = new Context();

        Plane plane = new Plane();
        context.setStrategy(plane);
        context.go();

        Bike bike = new Bike();
        context.setStrategy(bike);
        context.go();
    }
}
```



## 职责链模式

> 职责链模式（Chain of Responsibility Pattern），又称责任链模式。使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止



**角色**

- Handler，抽象处理者，定义了一个处理请求的接口，Handler角色直到下一个处理者是谁，如果自己无法处理，它会将请求转给下一个处理者，即下一个Handler对象
- ConcreteHandler，具体处理者，处理它自己负责的请求，可以访问后继处理者，如果可以处理当前请求则自己处理，否则将请求交给下一个处理者，从而形成一个职责链
- Client，请求者，向Handler发送请求

**细节**

- 职责链模式通常每个接收者都包含对另一个接收者的调用，如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，以此类推
- 职责链模式使每个对象都有机会处理请求，从而避免请求发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递请求，直到有对象能处理该请求为止
- 优点
  1. 将请求和处理分开，实现解耦，提高系统的灵活性
  2. 简化了对象，使请求对象不需要知道链的结构
- 缺点
  1. 性能会受到影响，特别是在链比较长的时候，因此炫耀控制链中最大节点数量，一般在通过Handler中设置一个最大节点数量，在Handler的`setNext()`方法中判断是否已经超过阈值，超过则不允许该链创建，避免出现超长链，无意识地破坏系统性能
  2. 调试不方便，采用了类似递归调用的方式，调用时逻辑可能比较复杂



```java
/**
 * Handler
 * @author gnl
 */

public abstract class Handler {

    protected Handler nextHandler;

    protected String name;

    /**
     * processRequest
     * @param request
     * @return void
     * @author gnl
     */
    public abstract void processRequest(Request request);

    public Handler(String name) {
        this.name = name;
    }

    public Handler getNextHandler() {
        return nextHandler;
    }

    public void setNextHandler(Handler nextHandler) {
        this.nextHandler = nextHandler;
    }
}

/**
 * FirstHandler ConcreteHandler
 *
 * @author gnl
 */

public class FirstHandler extends Handler {

    public FirstHandler(String name) {
        super(name);
    }

    @Override
    public void processRequest(Request request) {
        if (request.getDay() <= 3) {
            System.out.println("****************");
            System.out.println("请求id: " + request.getId());
            System.out.println("请求type: " + request.getType());
            System.out.println("请求day(s): " + request.getDay());
            System.out.println("处理人: " + super.name);
        } else {
            System.out.println( super.name + " 无法处理 " + request.getId());
            // 自己不能处理，交给下一个处理者处理
            super.nextHandler.processRequest(request);
        }
    }
}

/**
 * SecondHandler ConcreteHandler
 *
 * @author gnl
 */

public class SecondHandler extends Handler {

    public SecondHandler(String name) {
        super(name);
    }

    @Override
    public void processRequest(Request request) {
        if ( request.getDay() > 3 && request.getDay() <= 7) {
            System.out.println("****************");
            System.out.println("请求id: " + request.getId());
            System.out.println("请求type: " + request.getType());
            System.out.println("请求day(s): " + request.getDay());
            System.out.println("处理人: " + super.name);
        } else {
            System.out.println( super.name + " 无法处理 " + request.getId());
            // 自己不能处理，交给下一个处理者处理
            super.nextHandler.processRequest(request);
        }
    }
}

/**
 * ThirdHandler ConcreteHandler
 *
 * @author gnl
 */

public class ThirdHandler extends Handler {

    public ThirdHandler(String name) {
        super(name);
    }

    @Override
    public void processRequest(Request request) {
        if ( request.getDay() > 7) {
            System.out.println("****************");
            System.out.println("请求id: " + request.getId());
            System.out.println("请求type: " + request.getType());
            System.out.println("请求day(s): " + request.getDay());
            System.out.println("处理人: " + super.name);
        } else {
            // 自己不能处理，交给下一个处理者处理
            super.nextHandler.processRequest(request);
        }
    }
}

/**
 * Client
 * @author gnl
 */

public class Client {
    public static void main(String[] args) {
        Request request = new Request(1000, "请假", 12);
        Request request2 = new Request(1001, "请假", 3);

        FirstHandler firstHandler = new FirstHandler("组长");
        SecondHandler secondHandler = new SecondHandler("主管");
        ThirdHandler thirdHandler = new ThirdHandler("经理");

        firstHandler.setNextHandler(secondHandler);
        secondHandler.setNextHandler(thirdHandler);

        firstHandler.processRequest(request);
        firstHandler.processRequest(request2);

    }
}
```

